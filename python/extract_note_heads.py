#!/usr/bin/env python3
"""
svg_extract_note_heads.py

SVG Musical Notehead Extraction Pipeline  
========================================

This script extracts notehead positions and pitch information from SVG files
generated by LilyPond music notation software. It creates a dataset mapping
visual notehead locations to their corresponding musical pitches for use in
animated score following applications.

Process Overview:
1. Parse LilyPond-generated SVG to find clickable notehead elements
2. Extract pitch information from LilyPond source code via href links (file paths embedded in href)
3. Determine visual coordinates for each notehead
4. Create sorted dataset ordered by visual appearance (left-to-right, top-to-bottom)
5. Export CSV with required arguments for input SVG and output path

Input Files:
- SVG file with embedded LilyPond cross-references (href contains .ly file paths)

Output:
- CSV file with notehead coordinates, pitches, and reference links in format: snippet,href,x,y
"""

import re
import csv
import xml.etree.ElementTree as ET
import argparse
import os
import sys
import pandas as pd
from _scripts_utils import save_dataframe_with_lilypond_csv

# =============================================================================
# LILYPOND PITCH PATTERN MATCHING
# =============================================================================

# Regular expression to identify LilyPond note syntax in source code
# Matches: letter name + optional accidentals + optional octave marks
note_regex = re.compile(r"""
            ^                 # start of string
            ([a-g])        # pitch letter
            (isis|eses|is|es)?# optional accidentals
            \s*               # optional octave marks
            [,']*             # optional octave marks
        """, re.VERBOSE)

# =============================================================================
# LILYPOND SOURCE CODE PARSING FUNCTION
# =============================================================================

def extract_text_from_href(href):
    """
    Extract LilyPond pitch notation from cross-reference URLs.
    
    LilyPond embeds "textedit" URLs in SVG that point back to specific
    locations in the source .ly file. These URLs encode file path, line
    number, and column position, allowing us to extract the exact pitch
    notation that generated each visual notehead.
    
    Args:
        href (str): TextEdit URL from SVG (e.g., "textedit:///work/file.ly:25:10")
        
    Returns:
        str or None: LilyPond pitch notation (e.g., "cis'") or None if not found
        
    URL Format: textedit:///work/filepath:line:column
    - filepath: Path to .ly source file (extracted from href)
    - line: 1-based line number  
    - column: 1-based character position
    """
    try:
        # Clean up URL format - remove textedit protocol prefix
        if href.startswith("textedit:///work/"):
            href = href[len("textedit:///work/"):]
        else:
            return "(invalid href format)"

        # Parse URL components: "file.ly:line:column"
        parts = href.split(":")
        file_path = parts[0]
        line = int(parts[1]) - 1      # Convert to 0-based indexing
        col_start = int(parts[2])     # 1-based column position

        # Read the specific LilyPond source file referenced in the href
        with open(file_path, encoding="utf-8") as f:
            lines = f.readlines()

        # Extract text from the specified position to end of line
        text_line = lines[line][col_start:]
        text = text_line.strip().strip("[]<>()")
        
        # Attempt to match LilyPond note pattern
        match = note_regex.match(text)

        if match:
            # Return the matched note notation without extra whitespace
            return match.group(0).replace(" ", "")
        else:
            # Return None if no valid note pattern found
            return None

    except Exception as e:
        return f"(error: {e})"

def setup_argument_parser():
    """Setup command line argument parser."""
    parser = argparse.ArgumentParser(
        description="Extract notehead positions and pitch information from SVG files",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python extract_note_heads.py -i score.svg -o noteheads.csv
  python extract_note_heads.py --input music.svg --output music_note_heads.csv
        """
    )
    
    parser.add_argument('-i', '--input', 
                       required=True,
                       help='Input SVG file path (required)')
    
    parser.add_argument('-o', '--output',
                       required=True, 
                       help='Output CSV file path for noteheads (required)')
    
    return parser.parse_args()

def main():
    """Main function with command line argument support."""
    
    print("üéº SVG Notehead Extractor")
    print("=" * 50)
    
    # Parse arguments
    args = setup_argument_parser()
    
    svg_file = args.input
    output_csv = args.output
    
    print(f"üìÑ Input SVG: {svg_file}")
    print(f"üìä Output CSV: {output_csv}")
    print()

    # =================================================================
    # XML NAMESPACE SETUP AND FILE LOADING
    # =================================================================

    try:
        print("üîç Loading and parsing SVG file...")

        # Verify SVG file exists
        if not os.path.exists(svg_file):
            raise FileNotFoundError(f"SVG file not found: {svg_file}")

        # Load SVG file
        with open(svg_file, encoding="utf-8") as f:
            svg = ET.parse(f)

        # SVG namespaces for XPath queries
        NS = {'svg': 'http://www.w3.org/2000/svg', 'xlink': 'http://www.w3.org/1999/xlink'}
        root = svg.getroot()

        # =================================================================
        # NOTEHEAD DISCOVERY AND COORDINATE EXTRACTION
        # =================================================================

        print("üìç Extracting notehead positions and pitch data...")

        # Storage for discovered noteheads
        notehead_data = []

        # Find all clickable <a> elements (these contain the noteheads)
        for a in root.findall(".//svg:a", NS):
            # Get the cross-reference URL
            href = a.get(f"{{{NS['xlink']}}}href")
            
            # Extract pitch information from the href
            snippet = extract_text_from_href(href)

            # Skip if we couldn't extract valid pitch information
            if not snippet is None:
                # Find the graphical group element containing visual positioning
                g = a.find("svg:g", NS)
                
                if g is not None:
                    # Extract coordinate transformation from the group's transform attribute
                    transform = g.attrib.get("transform", "")
                    
                    # Parse translation coordinates: "translate(x, y)" or "translate(x,y)"
                    match = re.search(r"translate\(([-\d.]+)[ ,]+([-\d.]+)", transform)
                    
                    if not match:
                        print(f"no matching transform near <a> of [{href}] for snippet [{snippet}]")
                    
                    if match:
                        # Extract and convert coordinates
                        x = float(match.group(1))
                        y = float(match.group(2))
                        
                        # Store the notehead information
                        notehead_data.append({
                            "x": x,
                            "y": y,
                            "href": href,
                            "snippet": snippet
                        })

        print(f"   üìä Processed {len(root.findall('.//svg:a', NS))} anchor elements")
        print(f"   ‚úÖ Found {len(notehead_data)} valid noteheads with pitch data") 

        # =================================================================
        # SPATIAL SORTING FOR VISUAL ALIGNMENT
        # =================================================================

        print("üìê Sorting noteheads by visual position...")

        # Sort noteheads by visual reading order:
        # 1. Primary sort: x-coordinate (left to right across the staff)  
        # 2. Secondary sort: y-coordinate (top to bottom for simultaneous notes)
        #    Note: Negative y-coordinate because SVG y=0 is at top, music reads top-to-bottom
        notehead_data.sort(key=lambda n: (n["x"], -n["y"]))  # descending y = top-to-bottom

        print(f"   üéØ Sorted {len(notehead_data)} noteheads in reading order")

        # =================================================================
        # CSV EXPORT
        # =================================================================

        print(f"üíæ Writing results to {output_csv}...")

        # Convert notehead data to DataFrame for consistent CSV handling
        notehead_df = pd.DataFrame(notehead_data)
        
        # Reorder columns to match requested format: snippet, href, x, y
        notehead_df = notehead_df[["snippet", "href", "x", "y"]]
        
        # Round coordinates to 3 decimal precision
        notehead_df["x"] = notehead_df["x"].round(3)
        notehead_df["y"] = notehead_df["y"].round(3)
        
        # Use utility function to handle LilyPond notation CSV quoting
        save_dataframe_with_lilypond_csv(notehead_df, output_csv)

        # =================================================================
        # COMPLETION SUMMARY
        # =================================================================

        extraction_summary = f"[ extracted {len(notehead_data)} noteheads with coordinates and pitch data ]"
        print(f"‚úÖ Export complete: {output_csv} {extraction_summary}")

        # Additional statistics for verification
        if notehead_data:
            x_range = max(n["x"] for n in notehead_data) - min(n["x"] for n in notehead_data)
            y_range = max(n["y"] for n in notehead_data) - min(n["y"] for n in notehead_data)
            unique_pitches = len(set(n["snippet"] for n in notehead_data))
            
            print(f"\nüìä Extraction Statistics:")
            print(f"   üìè X-coordinate range: {x_range:.1f} units")
            print(f"   üìê Y-coordinate range: {y_range:.1f} units") 
            print(f"   üéµ Unique pitch notations: {unique_pitches}")
            print(f"   üîó Average notes per pitch: {len(notehead_data)/unique_pitches:.1f}")

        print()
        print("üéâ Notehead extraction completed successfully!")
        print(f"üéØ Ready for alignment with MIDI data in next pipeline stage")

    except FileNotFoundError as e:
        print(f"‚ùå File error: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"‚ùå Unexpected error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()