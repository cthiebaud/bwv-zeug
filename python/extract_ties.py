#!/usr/bin/env python3
"""
extract_ties.py - Extract tie relationships from SVG files

This script parses SVG files generated by LilyPond to extract tie relationships
between noteheads, using the data-tie-from and data-tie-to attributes added by
the tie-attributes.ily engraver.

The script handles all tie scenarios:
- Simple ties (start ‚Üí end)
- Tie chains (start ‚Üí both ‚Üí both ‚Üí ... ‚Üí end)
- Chord ties (multiple simultaneous tie relationships)

The script can work in two modes:
1. Build system mode: Uses PROJECT_NAME environment variable for file naming
2. Standalone mode: Requires explicit input/output file arguments

Input: SVG file with tie data attributes
Output: CSV file with tie relationships in format: primary,secondary
"""

import xml.etree.ElementTree as ET
import csv
import os
import sys
import argparse
from pathlib import Path

def extract_ties_from_svg(svg_file_path):
    """
    Extract tie relationships from an SVG file.
    
    This function processes all tie-related data attributes:
    - data-tie-role: "start", "end", "both"
    - data-tie-from: Reference to the note this ties from
    - data-tie-to: Reference to the note this ties to
    
    Args:
        svg_file_path (str): Path to the SVG file
        
    Returns:
        list: List of tuples (primary_href, secondary_href) representing tie relationships
        
    Raises:
        FileNotFoundError: If SVG file doesn't exist
        ET.ParseError: If SVG file is malformed
    """
    print(f"üìñ Reading SVG file: {svg_file_path}")
    
    if not os.path.exists(svg_file_path):
        raise FileNotFoundError(f"SVG file not found: {svg_file_path}")
    
    try:
        tree = ET.parse(svg_file_path)
        root = tree.getroot()
    except ET.ParseError as e:
        raise ET.ParseError(f"Failed to parse SVG file {svg_file_path}: {e}")
    
    ties = []
    
    # First, collect all note elements with their IDs and hrefs for reference lookup
    note_id_to_href = {}
    for element in root.iter():
        element_id = element.get('id')
        if element_id and element_id.startswith('notehead-'):
            # Find href for this element
            href = find_element_href(element)
            if href:
                note_id_to_href[element_id] = clean_href_path(href)
    
    print(f"üìä Found {len(note_id_to_href)} noteheads with IDs")
    
    # Process all elements with tie data attributes
    for element in root.iter():
        tie_role = element.get('data-tie-role')
        
        if tie_role in ['start', 'both']:
            # This element starts a tie - look for data-tie-to
            tie_to = element.get('data-tie-to')
            if tie_to:
                primary_href = find_element_href(element)
                if primary_href:
                    # Extract target ID (remove '#' prefix)
                    target_id = tie_to[1:] if tie_to.startswith('#') else tie_to
                    secondary_href = note_id_to_href.get(target_id)
                    
                    if secondary_href:
                        primary_clean = clean_href_path(primary_href)
                        ties.append((primary_clean, secondary_href))
                        print(f"üîó Found tie: {primary_clean} ‚Üí {secondary_href}")
                    else:
                        print(f"‚ö†Ô∏è  Could not find href for target ID: {target_id}")
                else:
                    print(f"‚ö†Ô∏è  Could not find href for tie start element with role: {tie_role}")
        
        # Also handle legacy data-tie-from attributes (tie endings) as fallback
        tie_from = element.get('data-tie-from')
        if tie_from and not element.get('data-tie-to'):  # Only if not already processed as 'both'
            # Extract the source ID (remove the '#' prefix)
            source_id = tie_from[1:] if tie_from.startswith('#') else tie_from
            primary_href = note_id_to_href.get(source_id)
            
            if primary_href:
                secondary_href = find_element_href(element)
                if secondary_href:
                    secondary_clean = clean_href_path(secondary_href)
                    tie_pair = (primary_href, secondary_clean)
                    
                    # Avoid duplicates (might be already captured by data-tie-to processing)
                    if tie_pair not in ties:
                        ties.append(tie_pair)
                        print(f"üîó Found tie (fallback): {primary_href} ‚Üí {secondary_clean}")
                else:
                    print(f"‚ö†Ô∏è  Could not find href for tie end element")
            else:
                print(f"‚ö†Ô∏è  Could not find href for source ID: {source_id}")
    
    print(f"‚úÖ Extracted {len(ties)} tie relationships")
    return ties

def find_element_href(element):
    """
    Find the xlink:href attribute for an element, checking the element itself
    and its child <a> elements.
    
    Args:
        element: XML element to search
        
    Returns:
        str: href value or None if not found
    """
    # Check if element itself has an href
    href = element.get('{http://www.w3.org/1999/xlink}href')
    if href:
        return href
    
    # Look for href in child <a> elements
    for child in element.iter():
        child_href = child.get('{http://www.w3.org/1999/xlink}href')
        if child_href:
            return child_href
    
    return None

def clean_href_path(href):
    """
    Clean href path by removing LilyPond editor artifacts.
    
    Args:
        href (str): Raw href path from SVG
        
    Returns:
        str: Cleaned href path
        
    Example:
        "textedit:///work/file.ly:10:5:6" ‚Üí "file.ly:10:5:6"
    """
    # Remove textedit protocol and workspace path
    cleaned = href.replace("textedit://", "").replace("/work/", "")
    return cleaned

def load_existing_ties(csv_file_path):
    """
    Load existing tie relationships from CSV file.
    
    Args:
        csv_file_path (str): Path to existing CSV file
        
    Returns:
        set: Set of tuples representing existing tie relationships
    """
    existing_ties = set()
    
    if os.path.exists(csv_file_path):
        print(f"üìÇ Loading existing ties from: {csv_file_path}")
        try:
            with open(csv_file_path, 'r', newline='', encoding='utf-8') as csvfile:
                reader = csv.reader(csvfile)
                
                # Skip header if present
                first_row = next(reader, None)
                if first_row and (first_row[0].lower() == 'primary' or first_row[0].lower() == 'primary'):
                    # Header row detected, continue reading data
                    pass
                else:
                    # No header, treat first row as data
                    if first_row and len(first_row) >= 2:
                        existing_ties.add((first_row[0], first_row[1]))
                
                # Read remaining rows
                for row in reader:
                    if len(row) >= 2:
                        existing_ties.add((row[0], row[1]))
                        
        except Exception as e:
            print(f"‚ö†Ô∏è  Error reading existing CSV: {e}")
    else:
        print(f"üìù CSV file doesn't exist, will create new: {csv_file_path}")
    
    print(f"üìä Found {len(existing_ties)} existing tie relationships")
    return existing_ties

def save_ties_to_csv(ties, csv_file_path, existing_ties=None):
    """
    Save tie relationships to CSV file, merging with existing ties.
    
    Args:
        ties (list): List of new tie tuples to add
        csv_file_path (str): Path to output CSV file
        existing_ties (set): Set of existing tie relationships
    """
    if existing_ties is None:
        existing_ties = set()
    
    # Combine new and existing ties, removing duplicates
    all_ties = existing_ties.union(set(ties))
    new_ties_count = len(all_ties) - len(existing_ties)
    
    print(f"üíæ Saving {len(all_ties)} total ties ({new_ties_count} new) to: {csv_file_path}")
    
    # Ensure output directory exists
    os.makedirs(os.path.dirname(csv_file_path) if os.path.dirname(csv_file_path) else '.', exist_ok=True)
    
    try:
        with open(csv_file_path, 'w', newline='', encoding='utf-8') as csvfile:
            writer = csv.writer(csvfile)
            
            # Write header
            writer.writerow(['primary', 'secondary'])
            
            # Write ties sorted for consistency
            for primary, secondary in sorted(all_ties):
                writer.writerow([primary, secondary])
                
        print(f"‚úÖ Successfully saved ties to {csv_file_path}")
        
    except Exception as e:
        print(f"‚ùå Error saving CSV file: {e}")
        raise

def setup_argument_parser():
    """Setup command line argument parser with required input/output arguments."""
    parser = argparse.ArgumentParser(
        description="Extract tie relationships from SVG and update ties CSV",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python extract_ties.py -i score.svg -o ties.csv
  python extract_ties.py --input music.svg --output music_ties.csv
        """
    )
    
    parser.add_argument('-i', '--input', 
                       required=True,
                       help='Input SVG file path (required)')
    
    parser.add_argument('-o', '--output',
                       required=True, 
                       help='Output CSV file path for ties (required)')
    
    return parser.parse_args()

def main():
    """Main function with project context support."""
    
    print("üéº SVG Tie Extractor")
    print("=" * 50)
    
    # Parse arguments
    args = setup_argument_parser()
    
    # Use the required input and output arguments
    svg_file = args.input
    csv_file = args.output
    
    print(f"üìÑ Input SVG: {svg_file}")
    print(f"üìä Output CSV: {csv_file}")
    print()
    
    try:
        # Load existing ties from CSV
        existing_ties = load_existing_ties(csv_file)
        
        # Extract ties from SVG
        new_ties = extract_ties_from_svg(svg_file)
        
        if not new_ties:
            print("‚ö†Ô∏è  No tie relationships found in SVG file")
            print("   Make sure the SVG was generated with tie-attributes.ily")
            print("   and that the Tie_data_engraver was properly applied")
        
        # Save combined ties to CSV
        save_ties_to_csv(new_ties, csv_file, existing_ties)
        
        print()
        print("üéâ Tie extraction completed successfully!")
        
        # Summary of tie types found
        if new_ties:
            print()
            print("üìà Tie Analysis Summary:")
            print(f"   üîó Total tie relationships: {len(new_ties)}")
            
            # Group ties by their file patterns to identify potential chains
            tie_files = {}
            for primary, secondary in new_ties:
                file_part = primary.split(':')[0] if ':' in primary else primary
                if file_part not in tie_files:
                    tie_files[file_part] = []
                tie_files[file_part].append((primary, secondary))
            
            for file_name, file_ties in tie_files.items():
                print(f"   üìÑ {file_name}: {len(file_ties)} tie(s)")
        
    except FileNotFoundError as e:
        print(f"‚ùå File not found: {e}")
        sys.exit(1)
        
    except ET.ParseError as e:
        print(f"‚ùå SVG parsing error: {e}")
        sys.exit(1)
        
    except Exception as e:
        print(f"‚ùå Unexpected error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()